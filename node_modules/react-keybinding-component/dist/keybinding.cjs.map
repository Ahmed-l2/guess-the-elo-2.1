{"version":3,"sources":["../src/keybinding.tsx"],"sourcesContent":["import { useCallback, useEffect } from 'react';\n\nexport type KeybindingProps = {\n  onKey: (e: KeyboardEvent) => void;\n  type?: 'keydown' | 'keyup';\n  target?: string | HTMLElement | Document | Window;\n  preventInputConflict?: boolean;\n  preventContentEditableConflict?: boolean;\n  preventDefault?: boolean;\n  stopPropagation?: boolean;\n};\n\nconst TARGETS_BLACKLIST = ['textarea', 'input', 'select'];\n\n/**\n * Get the actual target to which we should attach the event\n */\nfunction getTarget(\n  target: NonNullable<KeybindingProps['target']>,\n): HTMLElement | Document | Window {\n  if (typeof target === 'string') {\n    const element = document.querySelector<HTMLElement>(target);\n    if (!element) {\n      throw new Error(\n        `Selector \"${target}\" returned null (on keybinding mount)`,\n      );\n    }\n\n    return element;\n  }\n\n  return target;\n}\n\n/**\n * Attaches an event to the DOM\n */\nexport default function Keybinding(props: KeybindingProps) {\n  const {\n    onKey,\n    type = 'keydown',\n    target = document, // Probably will make server-side rendering crash\n    preventInputConflict = false,\n    preventContentEditableConflict = false,\n    preventDefault = false,\n    stopPropagation = false,\n  } = props;\n\n  const onKeyEvent = useCallback(\n    (e: KeyboardEvent) => {\n      // is actually a KeyboardEvent\n      if (preventDefault) e.preventDefault();\n      if (stopPropagation) e.stopPropagation();\n\n      const target = e.target as HTMLElement | null;\n\n      if (target) {\n        let canDispatch = true;\n\n        if (\n          preventInputConflict &&\n          TARGETS_BLACKLIST.indexOf(target.tagName.toLowerCase()) > -1\n        ) {\n          canDispatch = false;\n        }\n\n        if (preventContentEditableConflict && checkIfContentEditable(target)) {\n          canDispatch = false;\n        }\n\n        if (canDispatch) onKey(e);\n      }\n    },\n    [\n      preventDefault,\n      stopPropagation,\n      preventInputConflict,\n      preventContentEditableConflict,\n      onKey,\n    ],\n  );\n\n  useEffect(() => {\n    const actualTarget = getTarget(target);\n\n    // @ts-ignore\n    actualTarget.addEventListener(type, onKeyEvent);\n\n    return () => {\n      // @ts-ignore\n      actualTarget.removeEventListener(type, onKeyEvent);\n    };\n  }, [target, type, onKeyEvent]);\n\n  return null;\n}\n\n/**\n * Return true if the current DOM node or one of its parent has the contenteditable\n * attribute activated\n */\nfunction checkIfContentEditable(node: HTMLElement | null) {\n  if (node === null) {\n    return false;\n  }\n\n  if (node.getAttribute('contenteditable') === 'true') {\n    return true;\n  }\n\n  return checkIfContentEditable(node.parentElement);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAAuC;AAYvC,IAAM,oBAAoB,CAAC,YAAY,SAAS,QAAQ;AAKxD,SAAS,UACP,QACiC;AACjC,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,UAAU,SAAS,cAA2B,MAAM;AAC1D,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI;AAAA,QACR,aAAa,MAAM;AAAA,MACrB;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAKe,SAAR,WAA4B,OAAwB;AACzD,QAAM;AAAA,IACJ;AAAA,IACA,OAAO;AAAA,IACP,SAAS;AAAA;AAAA,IACT,uBAAuB;AAAA,IACvB,iCAAiC;AAAA,IACjC,iBAAiB;AAAA,IACjB,kBAAkB;AAAA,EACpB,IAAI;AAEJ,QAAM,iBAAa;AAAA,IACjB,CAAC,MAAqB;AAEpB,UAAI;AAAgB,UAAE,eAAe;AACrC,UAAI;AAAiB,UAAE,gBAAgB;AAEvC,YAAMA,UAAS,EAAE;AAEjB,UAAIA,SAAQ;AACV,YAAI,cAAc;AAElB,YACE,wBACA,kBAAkB,QAAQA,QAAO,QAAQ,YAAY,CAAC,IAAI,IAC1D;AACA,wBAAc;AAAA,QAChB;AAEA,YAAI,kCAAkC,uBAAuBA,OAAM,GAAG;AACpE,wBAAc;AAAA,QAChB;AAEA,YAAI;AAAa,gBAAM,CAAC;AAAA,MAC1B;AAAA,IACF;AAAA,IACA;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAEA,8BAAU,MAAM;AACd,UAAM,eAAe,UAAU,MAAM;AAGrC,iBAAa,iBAAiB,MAAM,UAAU;AAE9C,WAAO,MAAM;AAEX,mBAAa,oBAAoB,MAAM,UAAU;AAAA,IACnD;AAAA,EACF,GAAG,CAAC,QAAQ,MAAM,UAAU,CAAC;AAE7B,SAAO;AACT;AAMA,SAAS,uBAAuB,MAA0B;AACxD,MAAI,SAAS,MAAM;AACjB,WAAO;AAAA,EACT;AAEA,MAAI,KAAK,aAAa,iBAAiB,MAAM,QAAQ;AACnD,WAAO;AAAA,EACT;AAEA,SAAO,uBAAuB,KAAK,aAAa;AAClD;","names":["target"]}